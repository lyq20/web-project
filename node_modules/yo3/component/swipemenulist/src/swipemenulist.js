'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _list = require('../../list/src/list');

var _list2 = _interopRequireDefault(_list);

var _swipemenu = require('../../swipemenu/src/swipemenu');

var _swipemenu2 = _interopRequireDefault(_swipemenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @component SwipeMenuList
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @version 3.0.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @description SwipeMenuList组件，使用List实现，列表项全部为SwipeMenu。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @instructions {instruInfo: ./swipeMenuList.md}{instruUrl: swipemenulist.html?hideIcon}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @author jiao.shen
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */


var noop = function noop() {};

var SwipeMenuList = function (_Component) {
    _inherits(SwipeMenuList, _Component);

    function SwipeMenuList(props) {
        _classCallCheck(this, SwipeMenuList);

        var _this = _possibleConstructorReturn(this, (SwipeMenuList.__proto__ || Object.getPrototypeOf(SwipeMenuList)).call(this, props));

        _this.swipeMenuList = [];
        // 当前打开的菜单index
        _this.openIndex = -1;
        // 之前打开菜单的index,用来判断菜单的打开/关闭状态是否有变化
        _this.cachedOpenIndex = -1;
        _this.state = {
            dataSource: _this.ds,
            openIndex: _this.openIndex
        };
        return _this;
    }

    _createClass(SwipeMenuList, [{
        key: 'getChildContext',
        value: function getChildContext() {
            return { swipeMenuList: this };
        }

        /**
         * 在render结束时重置缓存的上一个打开菜单的index，此时this.cachedOpenIndex===this.openIndex
         */

    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate() {
            this.cachedOpenIndex = this.openIndex;
        }

        /**
         * 在一个菜单被打开/关闭时触发，改变openIndex
         * @param index
         */

    }, {
        key: 'updateOpenIndex',
        value: function updateOpenIndex(index) {
            // 保存当前的openIndex
            this.cachedOpenIndex = this.openIndex;
            // 更新openIndex
            // 此时this.cachedOpenIndex!==this.openIndex
            this.openIndex = index;
            this.setState({ openIndex: index });

            var _props = this.props,
                onMenuOpen = _props.onMenuOpen,
                onMenuClose = _props.onMenuClose,
                dataSource = _props.dataSource;

            var itemData = typeof dataSource.get === 'function' ? dataSource.get(index) : dataSource[index];
            if (index !== -1) {
                onMenuOpen(itemData, index);
            } else {
                var lastOpenedItemData = typeof dataSource.get === 'function' ? dataSource.get(this.cachedOpenIndex) : dataSource[this.cachedOpenIndex];
                onMenuClose(lastOpenedItemData, this.cachedOpenIndex);
            }
        }

        /**
         * @method refresh
         * @description 在GroupList容器尺寸发生变化时调用，刷新内部的Scroller组件。
         * @version 3.0.6
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            if (this.list) this.list.refresh();
        }

        /**
         * @method resetLoadStatus
         * @param {Bool} hasLoadMore 是否能够加载更多，如果传入false，加载更多区域的文字将会变成 没有更多了，并且继续向下滚动时不会触发onLoadMore。
         * @description 重置加载更多功能。
         * @version 3.0.7
         */

    }, {
        key: 'resetLoadStatus',
        value: function resetLoadStatus(hasLoadMore) {
            if (this.list) this.list.resetLoadStatus(hasLoadMore);
        }

        /**
         * @description 滚动到某个位置
         * @method scrollTo
         * @param {Number} y y坐标
         * @param {Number} [time] 动画持续时间
         */

    }, {
        key: 'scrollTo',
        value: function scrollTo(y, time) {
            if (this.list) this.list.scrollTo(y, time);
        }

        /**
         * @method stopRefreshing
         * @param {Bool} [success] 下拉刷新是否成功，默认为 false。
         * @param {Object} [config] 停止刷新的动画配置。
         * @param {number} [config.duration] 回到顶部的动画时间，默认是 300ms。
         * @param {Function} [callback] 回到顶部的动画执行完毕的回调。
         * @description 调用 Scroller 同名方法，中止下拉刷新过程。在列表发生下拉刷新之后你应该调用这个方法去中止它(比如服务器响应已经返回的时候),否则刷新不会自动终止。
         */

    }, {
        key: 'stopRefreshing',
        value: function stopRefreshing(success, config, callback) {
            if (this.list) {
                this.list.stopRefreshing(success, config, callback);
            }
        }

        /**
         * @method startRefreshing
         * @description 模拟下拉刷新
         */

    }, {
        key: 'startRefreshing',
        value: function startRefreshing() {
            if (this.list) this.list.startRefreshing();
        }

        /**
         * @method stopAnimate
         * @description 让列表立刻停止滚动。
         */

    }, {
        key: 'stopAnimate',
        value: function stopAnimate() {
            if (this.list) this.list.stopAnimate();
        }

        /**
         * @description 停止加载更多
         * @method stopLoading
         * @param {Bool} success 加载成功/加载失败
         */

    }, {
        key: 'stopLoading',
        value: function stopLoading(success) {
            if (this.list) this.list.stopLoading(success);
        }

        /**
         * 关闭打开的菜单
         * 解锁Scroller
         */

    }, {
        key: 'closeAll',
        value: function closeAll(i) {
            var swipeMenu = this.swipeMenuList[this.openIndex];
            if (swipeMenu) {
                if (i !== this.openIndex) {
                    swipeMenu.close();
                }
                this.updateOpenIndex(-1);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var _props2 = this.props,
                _renderItem = _props2.renderItem,
                getMenuConfig = _props2.getMenuConfig,
                _shouldItemUpdate = _props2.shouldItemUpdate;


            return _react2.default.createElement(_list2.default, _extends({}, this.props, {
                // 如果有菜单被打开,锁定滚动
                disabled: this.openIndex !== -1,
                directionLockThreshold: 3,
                ref: function ref(list) {
                    if (list) _this2.list = list;
                }
                // 根据菜单打开/关闭状态是否有变化,决定是否需要render列表项
                , shouldItemUpdate: function shouldItemUpdate(next, now) {
                    if (_this2.props.infinite) {
                        return _this2.cachedOpenIndex !== _this2.openIndex || _shouldItemUpdate(next, now);
                    }
                    return false;
                }
                // 渲染列表项
                , renderItem: function renderItem(item, i) {
                    var menuConfig = getMenuConfig(item, i);
                    var action = menuConfig.action,
                        disable = menuConfig.disable;
                    // 重新包装action 菜单配置对象的tap方法,使其能够接收item,i,component为参数

                    action.forEach(function (actionObj) {
                        var origTap = actionObj.onTap;
                        //  以包裹后的tap方法替换原有tap方法,为了tap能够拿到参数
                        //  binded标志可以防止重复绑定
                        if (!origTap.binded) {
                            actionObj.onTap = function (component) {
                                origTap(item, i, component);
                            };
                            actionObj.onTap.binded = true;
                        }
                    });
                    return _react2.default.createElement(
                        _swipemenu2.default,
                        _extends({}, menuConfig, {
                            ref: function ref(component) {
                                if (component) {
                                    _this2.swipeMenuList[i] = component;
                                }
                            },
                            disable: disable || _this2.openIndex !== -1 && i !== _this2.openIndex,
                            onOpen: function onOpen() {
                                return _this2.updateOpenIndex(i);
                            },
                            onClose: function onClose() {
                                if (_this2.state.openIndex !== -1) {
                                    _this2.updateOpenIndex(-1);
                                }
                            },
                            action: action,
                            extraClass: 'swipemenu-list-menu'
                        }),
                        _renderItem(item, i)
                    );
                },
                onItemTap: function onItemTap(item, i, target) {
                    // 只有在内容区域的点击才触发onItemTap
                    _this2.props.onItemTap(item, i, target);
                },
                onItemTouchStart: function onItemTouchStart(item, i, evt) {
                    evt.preventDefault();

                    var currentTarget = evt.currentTarget;
                    var front = currentTarget.childNodes[0].childNodes[0];
                    var action = currentTarget.childNodes[0].childNodes[1];
                    var target = evt.target;
                    var touchInFront = target === front;
                    while (target !== front && target !== action) {
                        if (target == null) {
                            touchInFront = true;
                            break;
                        }
                        if (target.parentNode === front) {
                            touchInFront = true;
                            break;
                        }
                        if (target.parentNode === action) {
                            touchInFront = false;
                            break;
                        }
                        target = target.parentNode;
                    }

                    if (touchInFront) {
                        _this2.closeAll(i, evt);
                    }
                }
            }));
        }
    }]);

    return SwipeMenuList;
}(_react.Component);

SwipeMenuList.propTypes = {
    /**
     * @property dataSource
     * @type Array/Immutable List
     * @default null
     * @description 组件数据源，数组类型，与`List`同名属性完全一致。
     */
    dataSource: _propTypes2.default.oneOfType([_propTypes2.default.arrayOf(_propTypes2.default.shape({
        height: _propTypes2.default.number,
        text: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
        key: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string])
    })), _propTypes2.default.object]).isRequired,
    /**
     * @property uniqueKeyName
     * @type String
     * @default 'key'
     * @version 3.1.3
     * @description dataSource 数组项的唯一标识的键值，默认为 key。
     *
     * 例子:`` renderItem={(item)=><p>{item.someAttr}</p>} ``
     */
    uniqueKeyName: _propTypes2.default.string,
    /**
     * @property getMenuConfig
     * @default null
     * @version 3.0.3
     * @type Function
     * @param {Object} item 列表项对应的数据对象
     * @param {Number} index 列表项在数据源中的index
     * @description 这个函数应该返回一个列表项菜单对应的SwipeMenu组件配置对象，
     * 可配置的属性请参考`SwipeMenu`组件。
     */
    getMenuConfig: _propTypes2.default.func.isRequired,
    /**
     * @property renderItem
     * @type Function
     * @default null
     * @param {Object} item 列表项对应的数据对象
     * @param {Number} index 列表项在数据源中的index
     * @description 渲染列表项的函数，接受参数item(该项对应的数据源中的配置对象)，index(配置对象在数据源中的index)，返回JSX或者string
     * 作为SwipeMenu的内容
     */
    renderItem: _propTypes2.default.func,
    /**
     * @property staticSection
     * @type Element
     * @default null
     * @version 3.0.3
     * @description 在所有列表项之上渲染的一块静态区域，在开启Infinite模式时，这块区域不会参与列表项的回收复用。
     */
    staticSection: _propTypes2.default.element,
    /**
     * @property infinite
     * @type Bool
     * @default false
     * @description 是否开启无穷列表模式，参考List同名属性
     */
    infinite: _propTypes2.default.bool,
    /**
     * @property infiniteSize
     * @type Bool
     * @default 20
     * @description 无穷列表模式中，设置保留在容器中的列表项数量，参考List同名属性
     */
    infiniteSize: _propTypes2.default.number,
    /**
     * @property itemHeight
     * @type Number
     * @default null
     * @description 列表项高度，参考List同名属性
     */
    itemHeight: _propTypes2.default.number,
    /**
     * @property itemExtraClass
     * @type Function
     * @default "item swipemenu-list-item"
     * @param {Object} item 列表项对应的数据对象
     * @param {Number} index 列表项在数据源中的偏移
     * @description 列表项class，可以传入函数/字符串，参考List同名属性
     */
    itemExtraClass: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    /**
     * @property onItemTap
     * @type Function
     * @default null
     * @param {Object} item 列表项对应的数据对象
     * @param {Number} index 列表项在数据源中的偏移
     * @param {Array} dataSource 数据源
     * @description item点击事件回调，参考List同名属性。
     *
     * 注意:点击swipemenu的按钮区域以及菜单展开时不会触发这个事件。
     */
    onItemTap: _propTypes2.default.func,
    /**
     * @property itemTouchClass
     * @type String/Function
     * @default item-touch
     * @param {Object} item 列表项对应的数据对象
     * @param {Number} index 列表项在数据源中的index
     * @description 列表项被点击时的className，可以接收字符串或者函数，使用方式与itemExtraClass一致。
     * @version 3.0.2
     */
    itemTouchClass: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
    /**
     * @property extraClass
     * @type String
     * @default null
     * @description 给List容器dom添加的额外class
     */
    extraClass: _propTypes2.default.string,
    /**
     * @property style
     * @type Object
     * @default null
     * @description 给组件容器节点绑定的额外样式
     * @version 3.0.2
     */
    style: _propTypes2.default.object,
    /**
     * @property usePullRefresh
     * @type Bool
     * @default false
     * @description 是否开启下拉刷新
     */
    usePullRefresh: _propTypes2.default.bool,
    /**
     * 下拉刷新高度
     *
     * @property pullRefreshHeight
     * @type Number
     * @description 触发下拉刷新状态的高度（一般即为下拉刷新提示区域的高度）
     * @default 40
     */
    pullRefreshHeight: _propTypes2.default.number,
    /**
     * 下拉刷新渲染函数
     *
     * @property renderPullRefresh
     * @type Function
     * @returns {Element} 用来渲染 pullRefresh 的 JSX
     * @description
     *
     * 自定义的下拉刷新渲染函数
     */
    renderPullRefresh: _propTypes2.default.func,
    /**
     * @property onRefresh
     * @type Function
     * @default null
     * @param {Array} dataSource 列表数据源
     * @description 下拉刷新完成回调
     */
    onRefresh: _propTypes2.default.func,
    /**
     * @property useLoadMore
     * @type Bool
     * @default false
     * @description 是否开启加载更多
     */
    useLoadMore: _propTypes2.default.bool,
    /**
     * 加载更多高度
     *
     * @property loadMoreHeight
     * @type Number
     * @description 触发加载更多状态的高度（一般即为加载更多提示区域的高度）
     * @default 40
     */
    loadMoreHeight: _propTypes2.default.number,
    /**
     * 加载更多渲染函数
     *
     * @property renderLoadMore
     * @type Function
     * @returns {Element} 用来渲染 loadMore 的 JSX
     * @description
     * 自定义的加载更多渲染函数
     */
    renderLoadMore: _propTypes2.default.func,
    /**
     * @property onLoad
     * @type Function
     * @default null
     * @param {Array} dataSource 列表数据源
     * @description 加载更多回调
     */
    onLoad: _propTypes2.default.func,
    /**
     * @property offsetY
     * @type Number
     * @default 0
     * @description 列表初始Y轴偏移
     */
    offsetY: _propTypes2.default.number,
    /**
     * 内容底部留白
     *
     * @property contentInset
     * @type Number
     * @description 内容区域周围的留白，**目前仅支持 bottom**。主要用于适配 iPhoneX，在下方留出一定间隙。有『加载更多』时，显示在『加载更多』的下方。可以通过设置背景色来改变留白的颜色。
     * @default {bottom:0}
     * @version 3.0.13
     */
    contentInset: _propTypes2.default.shape({
        bottom: _propTypes2.default.number
    }),
    /**
     * @property onScroll
     * @type Function
     * @default null
     * @param {Number} offsetY y坐标
     * @description 列表滚动时触发的回调
     */
    onScroll: _propTypes2.default.func,
    /**
     * @property onScrollEnd
     * @type Function
     * @param {Number} offsetY 当前 Scroller 的 y 轴偏移量
     * @default null
     * @version 3.1.4
     * @description 滚动结束之后的回调
     */
    onScrollEnd: _propTypes2.default.func,
    /**
     * @property shouldItemUpdate
     * @type Function
     * @default null
     * @param {Object} next 即将传给列表项组件的item对象
     * @param {Object} now 当前列表项组件对应的item对象
     * @description 绑定给列表项组件的shouldComponentUpdate，可以避免额外的render，用于提升列表的滚动性能。
     * 详情请参考List组件同名属性。
     */
    shouldItemUpdate: _propTypes2.default.func,
    /**
     * @property deceleration
     * @type Number
     * @description 滚动视图开始惯性滚动时减速的加速度，默认为0.010。
     * @version 3.0.6
     */
    deceleration: _propTypes2.default.number,
    onInfiniteAppend: _propTypes2.default.func,
    /**
     * @property onMenuOpen
     * @type Function
     * @default ()=>{}
     * @param {Object} item 打开的菜单项对应的数据对象
     * @param {Number} index 打开的菜单项在dataSource中的index
     * @description 在某个菜单项打开的时候触发的回调函数。
     * @version 3.0.2
     */
    onMenuOpen: _propTypes2.default.func,
    /**
     * @property onMenuClose
     * @type Function
     * @default ()=>{}
     * @param {Object} item 打开的菜单项对应的数据对象
     * @param {Number} index 打开的菜单项在dataSource中的index
     * @description 在某个菜单项关闭时触发的回调函数。
     * @version 3.0.2
     */
    onMenuClose: _propTypes2.default.func,
    /**
     * @property scrollWithoutTouchStart
     * @type Bool
     * @default false
     * @description ** 实验中的属性 **
     * 在默认情况下一次用户触发（非调用scrollTo方法）scroller的滚动需要由touchstart事件来启动，在某些情况下，例如scroller从disable状态切换到enable状态时，
     * 可能不能接收到这一瞬间的touchstart事件，这可能导致用户期待的滚动过程没有发生。
     * 开启这个属性为true以后将允许scroller用touchmove启动滚动过程，这可以解决上述场景的问题。
     * @version 3.0.2
     */
    scrollWithoutTouchStart: _propTypes2.default.bool,
    /**
     * @property stickyOffset
     * @type Number
     * @default 0
     * @description 给staticSection内部吸顶容器设置的y轴偏移。
     * @version 3.0.6
     */
    stickyOffset: _propTypes2.default.number
};
SwipeMenuList.defaultProps = {
    uniqueKeyName: 'key',
    renderItem: function renderItem(item) {
        return typeof item.get === 'function' ? item.get('text') : item.text;
    },

    infinite: false,
    infiniteSize: 20,
    itemHeight: null,
    itemExtraClass: 'swipemenu-list-item',
    extraClass: 'yo-list-absolute',
    onItemTap: noop,
    usePullRefresh: false,
    onRefresh: noop,
    useLoadMore: false,
    onLoad: noop,
    offsetY: 0,
    onInfiniteAppend: noop,
    onMenuOpen: function onMenuOpen() {},
    onMenuClose: function onMenuClose() {},

    scrollWithoutTouchStart: false,
    staticSection: null,
    shouldItemUpdate: function shouldItemUpdate() {
        return false;
    }
};
SwipeMenuList.childContextTypes = {
    swipeMenuList: _propTypes2.default.object
};
exports.default = SwipeMenuList;